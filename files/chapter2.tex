\chapter{Collegare i microfrontends}\label{ch:composizione}
Per far convivere i progetti realizzati dai vari team esistono varie metodologie. Questo
 presuppone che i team, nella loro autonomia, debbano comunque scambiarsi un minimo di informazioni e di vincoli
che servono alla corretta integrazione delle app web, chiamiamo questo insieme di dati \emph{contratto tra team}.

\section*{Collegamento tra pagine con links}
La soluzione più semplice è quella del collegamento tra pagine con link URL: in questo modo il contratto consiste negli indirizzi delle pagine,
che i team dovranno scambiarsi tra di loro.
Questa soluzione è quella che rende i team il più autonomi e disaccoppiati possibile, inoltre
si ha grande robustezza, in quanto se un progetto si corrompe, questo non influenza minimamente gli altri,
che possono anche essere detenuti in server diversi.

Lo svantaggio è che in una pagina web è possibile contenere informazioni provenienti da un solo team.

Questa soluzione viene usata quando è richiesta una forte robustezza, oppure quando si deve implementare 
i microfrontends in una app legacy già esistente.


\section*{Composizione tramite iframes}
L' iframe è un elemento HTML che permette di incorporare un'altra pagina HTML all'interno di quella corrente. \cite{mozillaiframe}

Questo elemento può essere usato per comporre fragments provenienti da teams differenti, visualizzandoli su un'unica
pagina web.
Un team si impegnerà a realizzare la pagina ospitante e dovrà far presente agli altri attori lo spazio riservato
ai loro fragments per evitare problemi di visualizzazione, questo dato, oltre che agli indirizzi
URL delle varie pagine, farà parte del contratto tra i team.

Un grande svantaggio dell’uso degli iframes è la loro incompatibilità con i motori di ricerca.
Infatti le informazioni che vediamo nella pagina non sono in unico file HTML, di conseguenza il motore di ricerca non profila le informazioni 
contenute negli iframes.

\subsection*{Composizione con Ajax}
Un modo per superare il problema dei motori di ricerca ai quali sono affetti gli iframes è quello di 
caricare i file HTML con Ajax.

La pagina ospitante, detta \emph{wrapper} ha il compito di caricare nel proprio DOM ( Document Object Model) i fragments dei vari 
team, con l'ausilio di un codice javascript, che utilizza la funzione fetch().

Il problema principale però è che l’Ajax request è asincrona, 
questo porta a dei ritardi nel caricamento completo della pagina.

\subsection*{Utilizzo del Routing Server-side}
Il routing è un elemento fondamentale dell’architettura microfrontend.
L’elemento che stiamo introducendo viene chiamato frontend proxy, cioè un web server che effettua routing,
 che intercetta le richieste con un certo percorso e le instrada al giusto fragment. In questo modo anche se
  i progetti dei vari team risiedono in spazi diversi, l’utente vedrà un URL omogeneo e non si accorgerà delle origini dei fragment.
Il funzionamento consiste in questi passaggi:
\begin{itemize}
    \item Il client apre l’ URL “/foo/bar”. La richiesta raggiunge il frontend proxy
    \item Il frontend proxy confronta il path “/foo/bar/“8 con la propria routing table, con corrispondenza in prossimità della regola i
    \item Il frontend proxy passa la richiesta al fragment associato
    \item Il fragment genera una risposta e la ritorna al frontdend proxy
    \item La risposta arriva infine al client
\end{itemize}


\pagebreak

\section*{Composizione Server-side}
Si suppone di lavorare ad un progetto microfrontend incentrato principalmente su contenuti e informazioni, senza particolari applicativi logici al suo interno.
Un esempio di sito incentrato sulle informazioni( anche detto \emph{content-centric}) è Wikipedia, le sue caratteristiche principali sono:
\begin{enumerate}
    \item Tempi brevi di caricamento delle pagine
    \item Ottimizzazione per motori di ricerca
    \item Assenza di particolari contenuto logici basati sull'interazione con l'utente
\end{enumerate}

Si introduce quindi la \textbf{composizione server-side}, che rispetta le richieste di un sito content-centric come Wikipedia.

La composizione dei fragment viene eseguita da un servizio che risiede nel server web, il client quindi riceve la pagina completa.

Come nel caso degli iframes, i team che producono i fragments devono fornire al team che detiene la pagina ospitante l'URL del loro codice di markup HTML.

Il team della pagina ospitante userà delle direttive 
per richiedere al server di aggiungere il codice di markup degli altri team in un preciso posto della schermata.

Un esempio di servizio di composizione è la funzione \textbf{SSI} (Server-Side Includes) di \textbf{Nginx}:

\subsection*{Server-Side Includes}

Nginx contiene il modulo \emph{ngx-http-ssi-module} che processa i comandi SSI.
 I comandi SSI sono istruzioni
inserite nelle pagine HTML della pagina ospitante. Un'istruzione SSI appare nella seguente sintassi:

   \begin{center}
    \verb|<!--#include virtual="url/da/includere -->|
   \end{center}

Avviene quindi questo:

\begin{enumerate}
    \item Il client effettua la richiesta della pagina
    \item Il webserver accetta la richiesta e verifica la presenza di eventuali direttive SSI
    \item Le direttive trovate vengono sostituite con il codice di markup reperibile all'url dell'attributo "virtual"
    \item Il client riceve la pagina completa
\end{enumerate}

Si noti che le prestazioni di composizione sono nettamente aumentate rispetto alla composizione con iframes, 
in quanto il client riceve la pagina già completa, effettuando un solo handshake HTML, indipendentemente dal numero
di fragment ospitati nella pagina. Inoltre i motori di ricerca possono profilare anche il contenuto dei fragments

\subsubsection*{Modalità di caricamento dei fragments}
Al contrario della soluzione con iframes, lo scorretto caricamento di un fragment può rallentare o addirittura bloccare 
il caricamento dell'intera pagina. Il webserver infatti prima di restituire la pagina aspetta di avere tutti  i suoi componenti.
La proprietà di Nginx chiamata \emph{proxy read timeout} permette di fissare un tempo massimo per il quale il webserver 
può aspettare un fragment.

Nel caso in cui il webserver non riesce a caricare un fragment esiste il comando SSI \textbf{stub}.
Si utilizza la direttiva \emph{block} che sostiuirà il fragment caricato senza successo con del codice HTML di riserva.
Il nuovo \emph{include} contiene il nuovo attributo stub, che ha il riferimento al block corrispondente, dovesse non andare
a buon fine la richiesta.
 TODO: METTI SNIPPET STUB
\subsection*{Alternative a SSI}
\subsubsection*{Zalando Tailor}
\subsubsection*{Podium}

\pagebreak
\section*{Composizione Client-side}

\subsection*{Comunicazione tra fragments}

\subsubsection*{Diretta}
\subsubsection*{Tramite il padre}
\subsubsection*{Event-bus}


\subsection*{Application Shell}


\subsubsection*{Routing a due livelli}




\pagebreak
\section*{Universal Rendering}